#!/usr/bin/env lua5.1
--------------------------------------------------------------------------
-- yaml-to-dndtex.lua   ‒  Convert character-sheet YAML to LaTeX macros
-- Usage:   lua yaml-to-dndtex.lua  file.yaml   > file.tex
--          cat file.yaml | lua yaml-to-dndtex.lua   > file.tex
--------------------------------------------------------------------------

------------------ classic print functions ---------------------
local stringf = string.format
local function printf(...) return io.stdout:write(stringf(...)) end
local function eprintf(...) return io.stderr:write(stringf(...)) end
local function fprintf(fd, ...) return fd:write(stringf(...)) end
local function dief(...) eprintf(...); os.exit(1) end
local function luaerrorf(...) return error(stringf(...)) end
local function runf(...) return os.execute(stringf(...)) end
local function warnf(...)
  io.stderr:write 'Warning: '; eprintf(...); io.stderr:write '\n'
end
local function outf(out, ...)
  table.insert(out, stringf(...))
  return out
end

local nothing = { }

-- Global validation errors list
local global_validation_errors = {}

local curfile, last_file_announced

local function verrorf(...)
  local msg = stringf(...)
  table.insert(global_validation_errors, msg)
  if last_file_announced ~= curfile then
    eprintf('Validation error in %s: %s\n', curfile, msg)
    last_file_announced = curfile
  else
    eprintf('Validation error: %s\n', msg)
  end
end

function string.lfind(self, ...)
  return self:lower():find(...)
end  

----------------------------------------------------------------

local basename = arg[0]:gsub('^.*/', '')

local function charoptions(parser)
  return parser
  :numarg(1)
end

local function gmoptions(parser)
  return parser:minarg(1)
end

local fields = require 'flags'.parser()
  :output_file('output as o'):help('where to write if not stdout')
  :bool('verbose as v')
  :bool('nocolor'):help('disable color')
  :bool('quiet as q'):help('suppress stdout from pdflatex')
  :bool('strict'):help('halt on field validation errors (default: warn and continue)')
  :bool('standalone as s'):help('emit just definitions, not full file')
  :string('layout as t as l'):help('template for character sheet')
  :string('templates', os.getenv 'CHARSHEETS' or '/home/nr/etc/dnd/resources/character-sheets')
         :help('directory where character-sheet templates live') 
  :wrap(basename == 'gmsheet' and gmoptions or charoptions)
  :parse(arg)

local default_layout = basename == 'charsheet' and 'silverpine' or 'gmsheet'

local vprintf = fields.verbose and eprintf or function() end

local pdflatex =
  fields.quiet and 'pdflatex -interaction=nonstopmode -halt-on-error -file-line-error -no-shell-escape'
    or 'pdflatex -interaction=scrollmode -halt-on-error -no-shell-escape'



local lyaml  = require "lyaml"
local function isnull(v) return v == lyaml.null end

assert(lyaml.dump)
local function image(v)
  return lyaml.dump({v}):gsub([[\]], [[\textbackslash{}]])
                        :gsub('\n', [[\emph{\scriptsize\textsc{nl}}]])
end


local function unbalanced_yaml_string(doc)
  if type(doc) == 'string' then
    local d = doc:gsub('%b{}', '')
    if d:find '[{}]' then return doc end
  elseif type(doc) == 'table' then
    for _, v in pairs(doc) do
      local d = unbalanced_yaml_string(v)
      if d then return d end
    end
  end
end

assert(unbalanced_yaml_string([[\documentclass[10pt]{article}]]) == nil)
assert(unbalanced_yaml_string([[\documentclass[10pt]article}]]) ~= nil)
assert(unbalanced_yaml_string([[\documentclass[10pt]{article]]) ~= nil)
assert(unbalanced_yaml_string([[\documentclass[10pt]}article{]]) ~= nil)

assert(unbalanced_yaml_string { FOOT = "} ASDF {" } == "} ASDF {")

local bad_input_tex = [[
\documentclass[12pt]{article}
\def\lbrace{\char`\{}
\def\rbrace{\char`\}}
\begin{document}
A YAML file was rejected because some part of it contained
unbalanced braces, which is a security risk.  The offending
string was as follows:
\begin{quote}
\ttfamily
$BAD
\end{quote}
\end{document}
]]


---------------------

local bad_control_sequences = { }
do
  for cs in ([[
catcode
openout
write
makeatletter
\input
\include
\openin
\openout
\read
\write
\immediate
\pdffilesize
\pdfmdfivesum
\pdfshellescape
\usepackage
\RequirePackage
\documentclass
\LoadClass
\bibliography
\bibliographystyle
\csname
\endcsname
\catcode
\def
\edef
\let
\futurelet
\loop
\repeat
\href
\url
\includegraphics
\input
\include
\usepackage
\RequirePackage
\openin
\read
\newread
\closein
\openout
\write
\newwrite
\closeout
\write18
\special
\shipout
\catcode
\globaldefs
\everyjob
\everypar
\everycr
\endlinechar
\lccode
\uccode
\sfcode
\mathcode
\delcode
\scantokens

\pdfobj
\pdfrefobj
\pdfannot
\pdfximage
\pdfcatalog
\pdfinfo
\pdfstartlink
\pdffilesize
\pdfmdfivesum
\pdffilemoddate
\pdffiledump

]]):gmatch [[%a+]] do
    bad_control_sequences['\\'..cs] = true
  end
end

local function sanitize_control_sequences(s)
  return (s:gsub([[%\%a+]],
            function(cs) if bad_control_sequences[cs] then
                return stringf([[\texttt{\textbackslash %s}]], cs:sub(2))
            end
  end))
end



--------- generator

local function scalarvalues(list)
  return coroutine.wrap(function()
      local function process(values)
        for _, value in pairs(values) do
          if type(value) == "table" then
            process(value)
          else
            coroutine.yield(value)
          end
        end
      end
      process(list)
    end)
end

local function named_things(doc)
  return coroutine.wrap(function()
    for _, section in ipairs {'MAGIC', 'FEATURES'} do
      local things = doc[section] or nothing
      for _, thing in ipairs(things) do
        if thing.name then
          coroutine.yield(thing)
        end
      end
    end
  end)
end


-------------------------------------------------
---
-- 
  


------------------------------------------------------------------------
--
-- Field validation

local function wrap(p)
  return function(v)
    if p(v) then return true else return false, v end
  end
end

local inrange = function(lo, hi)
  return wrap(function (v)
    return tonumber(v) and tonumber(v) >= lo and tonumber(v) <= hi
  end)
end

assert(type(inrange(1,10)) == 'function')

local isnumber = inrange(-math.huge, math.huge)

local function anyvalue(v)
  return true
end

local optional = function(p)
  return wrap(function (v) 
    -- Handle YAML null, nil, and empty string as valid "empty" values
    if v == '' or v == nil or isnull(v) then
      return true
    else
      return p(v)
    end
  end)
end

assert(type(optional(positive)) == 'function')

local function orp(p1, p2)
  return function(v)
    local ok, msg = p1(v)
    if ok then
      return ok
    else
      return p2(v)
    end
  end
end

-- Higher-order validator functions
local positive = inrange(1, math.huge)

local function all(p, list)
  for _, v in ipairs(list) do
    local ok, msg = p(v)
    if not ok then
      return ok, msg
    end
  end
  return true
end

local function any(p, list)
  local ok, msg
  for _, v in ipairs(list) do
    ok, msg = p(v)
    if ok then
      return ok
    end
  end
  return false, msg
end

local can_be_tab = {
  string = wrap(function(v)
             return type(v) == 'string' or type(v) == 'number' or type(v) == 'boolean'
             end),
  number = wrap(function(v) return tonumber(v) end),
}
setmetatable(can_be_tab, { __index = function(_, t)
                                       return wrap(function(v) return type(v) == t end)
                           end})

local function can_be(...)
  local types = { ... }
  return function(v) return any(function(t) return can_be_tab[t](v) end, types) end
end

assert(can_be 'string'('hello'))
assert(can_be 'string'(7))

local empty = wrap(function(v)
  return v == nil
      or type(v) == 'table' and next(v) == nil
      or type(v) == 'string' and not v:find '%S'
      or false
end)

local is_singleton_table = wrap(function(t)
  if type(t) == 'table' then
    local k, v = next(t)
    return k ~= nil and next(t, k) == nil
  end
end)

local islist = wrap(function(t)
  return type(t) == 'table' and (empty(t) or t[1] ~= nil)
end)

local function listof(predicate)
  return function(list)
    if not islist(list) then
      return false, list
    else
      local ok, msg = all(predicate, list)
      return ok, msg or "list contains invalid items"
    end
  end
end

local function validate_foreach(name, validator)
  if validator == nil then
    name, validator = '?', name
  end
  return function(list)
    if not islist(list) then
      verrorf('%s: entry %q is not a list', name, list)
    else
      for _, v in ipairs(list) do
        validator(v)
      end
    end
  end
end

local nonempty_string = wrap(function (v)
  return can_be 'string'(v) and tostring(v):find('%S')
end)


assert(nonempty_string 'Arborist')


local function convert_colon_tables(v)
--require 'inspect'.show { v = v, single = is_singleton_table(v) }
  if islist(v) then
    for i, e in ipairs(v) do
      v[i] = convert_colon_tables(e)
    end
    return v
  elseif not is_singleton_table(v) then
    return v
  else
    local k, e = next(v)
    if k == 'proficiencies_skip' and tostring(e) == 'true' then
      return [[\profskip{}]]
    elseif type(k) == 'string' then
--      if k:find 'skip' then require 'inspect'.show({ entry = entry}) end
      if isnull(e) then
        return stringf('%s:', k)
      elseif can_be 'string'(e) then
        return stringf('%s: %s', k, tostring(e))
--      elseif listof(can_be 'string')(e) then
--        -- we want to do this conversion if commas are used but not
--        -- if newlines and dashes are used.  But yaml can't tell the difference.
--        local items = { }
--        for _, item in ipairs(e) do
--          table.insert(items, tostring(item))
--        end
--        return stringf('%s: %s', k, table.concat(items, ', '))
      else
        v[k] = convert_colon_tables(e)
      end
    end
    return v
  end
  assert(false)
end
  



-- Extract valid equipment categories from category_map (single point of truth)
-- This will be updated after category_map is defined
local valid_equipment_categories

-- Attack field specifications - table-driven approach
local attack_field_specs = {
  { field = 'NAME',       predicate = can_be 'string', required = true },
  { field = 'ATTACK',     predicate = can_be 'string', required = true },
  { field = 'DAMAGE',     predicate = can_be 'string', required = true },
  { field = 'TYPE',       predicate = can_be 'string', required = true },
  { field = 'RANGE',      predicate = can_be 'string', },
  { field = 'AMMO TYPE',  predicate = can_be 'string' },
  { field = 'AMMO COUNT', predicate = can_be 'number', what = 'number' },
  { field = 'NOTES',      predicate = can_be 'string' }
}

-- Structure-specific validators
local function validate_attack_entry(attack)
  if not can_be 'table'(attack) then
    verrorf('Attack %s is not a table with attack fields', image(attack))
    return
  end
  
  -- Check each field according to its specification
  local missing = {}

  local name = can_be 'string'(attack.name) and tostring(attack.name) or image(attack)
  
  for _, spec in ipairs(attack_field_specs) do
    local field = spec.field
    if not attack[field] or attack[field] == lyaml.null then
      if spec.required then
        table.insert(missing, field)
      end
    else
      local valid, msg = spec.predicate(attack[field])
      if not valid then
        verrorf('Bad field %s in attack %q: expected a %s; got %s',
                field, name, spec.what or 'string', image(attack[field]))
      end
    end
  end

  if not empty(attack['AMMO COUNT']) and empty(attack['AMMO TYPE']) then
    verrorf('Attack %s specifies AMMO COUNT without an AMMO TYPE', name)
  end

  -- Combine all error messages
  if #missing > 0 then
    verrorf('Attack %q is missing these fields: %s', name, table.concat(missing, ", "))
  end
end

local function validate_feature_entry(feature)
  local required_fields = {'name', 'description'}
  if not can_be 'table'(feature) then
    verrorf('feature %q is not a table with name and description', image(feature))
  else
    if not nonempty_string(feature.name) then
      verrorf('feature%s is missing a name',
              not empty(feature.description)
              and stringf(' described as %q', tostring(feature.description):sub(1,12)..'...')
              or '')
    elseif not nonempty_string(feature.description) then
      verrorf('feature %q has no description', tostring(feature.name))
    end
  end
end

local function validate_spell_level(level)
  if not can_be 'number'(level) then
    verrorf('Spell level %s is not a number', image(level))
  else
    level = tonumber(level)
    if level < 0 or level > 9 then
      verrorf('spell level %d is out of range 0 to 9', level)
    end
  end
end

local function validate_spell_slots(level, slots)
  if level == 0 and slots == nil then
    -- all is well
  elseif not slots then
    verrorf('Number of slots for level %s not given', tostring(level))
  elseif not can_be 'number'(slots) then
    verrorf('For level %s, spell-slot count %s is not a number',
            tostring(level), require 'inspect'.image(slots))
  else
    slots = tonumber(slots)
    if slots <= 0 then
      verrorf("For level %s, spell-slot count %d isn't big enough",
              tostring(level), slots)
    end
  end
end

local magic_property = {
  bonus = 'the spell may be cast as a bonus action',
  reaction = 'the spell may be cast as a reaction',
  attack = 'casting the spell requires an attack roll',
  save = 'casting the spell requires an enemy to make a saving throw',
  enemy = 'the spell targets an enemy [implied by `attack` or `save`]',
  ritual = 'the spell may be cast as a ritual',
  duration = 'how long the spell lasts, if more than one action',
  concentration = 'the spell requires concentration',
  name = 'Name of the spell',
  description = 'How the spell works',
}


local function validate_magic_entry(entry)
  if not can_be 'table'(entry) then
    verrorf("MAGIC entry %q is not be a table", image(entry))
  elseif isnull(entry) then -- skip it
  elseif entry.level then
    -- Level entry
    validate_spell_level(entry.level)
    if entry.slots then
      validate_spell_slots (entry.level, entry.slots)
    end
  elseif nonempty_string(entry.name) then
    -- Spell entry
    if not nonempty_string(entry.description) then
        verrorf('spell %s does not have a description', tostring(entry.name))
    end
    for k in pairs(entry) do
      if not magic_property[k] then
        verrorf('spell %s is labeled with the unknown property %q',
                tostring(entry.name), k)
      end
    end
  elseif empty(entry.name) then
    verrorf('magic entry %q does not have a name', image(entry))
  else
    verrorf('magic entry name %q is not a string', image(entry.name))
  end
end

local function validate_equipment_structure(equipment)
  if not can_be 'table'(equipment) then
    verrorf('equipment entry %q should be a list of items', image(equipment))
  elseif listof(can_be 'string')(equipment) then
    -- flat list; no further validation
  else
    -- Structured format (object-style) 
    for category, items in pairs(equipment) do
      if not can_be'string'(category)
      or not valid_equipment_categories[tostring(category):upper()]
      then
        verrorf("invalid equipment category %q", category)
      end
      if not listof(can_be 'string')(items) then
        local _, bad = listof(can_be 'string')(items)
        verrorf('item %q in category %s is not a string', bad and image(bad) or '?',
                tostring(category))
      end
    end
  end
end


local validate_equipment = validate_equipment_structure
local validate_attacks = validate_foreach('ATTACKS', validate_attack_entry)
local validate_features = validate_foreach('FEATURES', validate_feature_entry)
local validate_magic = validate_foreach('MAGIC', validate_magic_entry)

-- Validate proficiencies structure (custom logic)
local function validate_proficiency_entry(entry)
  if empty(entry) then
    -- does for blank line
  elseif can_be'string'(entry) then
    -- all good
  elseif islist(entry) then
    validate_foreach('proficiency entry', validate_proficiency_entry)(entry)
  elseif is_singleton_table(entry) and next(entry) == 'proficiencies_skip' then
    -- Special entry (like proficiencies_skip)
    if not empty(entry.proficiencies_skip)
      and
      not can_be 'boolean'(entry.proficiencies_skip)
    then 
        verrorf("proficiencies_skip entry %s is not boolean",
                image(entry.proficiencies_skip))
    end
  elseif is_singleton_table(entry) then -- inner table
    local v, k = next(entry)
    if can_be'string'(v) and islist(k) then
      validate_proficiency_entry(k)
    else
      verrorf("proficiency %q is neither string nor empty nor list of proficiencies: %s", image(entry))
    end
  else
    verrorf("proficiency %q is neither string nor empty nor list of proficiencies: %s", image(entry), require 'inspect'.image(entry))
  end
end

local validate_proficiencies =
  validate_foreach('proficiencies', validate_proficiency_entry)

local casting_modifier = {
  Bard      = 'CHA',
  Cleric    = 'WIS',
  Druid     = 'WIS',
  Paladin   = 'CHA',
  Ranger    = 'WIS',
  Sorcerer  = 'CHA',
  Warlock   = 'CHA',
  Wizard    = 'INT',
}

local function get_class_from_doc(doc)
  -- Try CLASS & first LEVEL
  if not empty(doc['CLASS & LEVEL']) then
    local class = doc['CLASS & LEVEL']:match('%a+')
    return class
  end
  
  -- Fall back to CLASS field
  if not empty(doc.CLASS) then
    return doc.CLASS:match('%a+')
  end
  
  return nil
end

-- Validate CLASS & LEVEL requirement and parsing
local function validate_class_level_requirement(doc)
  local has_class_level = doc['CLASS & LEVEL'] and doc['CLASS & LEVEL']:find('%S')
  local has_separate = doc.CLASS and doc.CLASS:find('%S') and doc.LEVEL
  
  if not has_class_level and not has_separate then
    return false, "must have either 'CLASS & LEVEL' field or both 'CLASS' and 'LEVEL' fields"
  end
  
  -- If CLASS & LEVEL exists, validate it can be parsed
  if has_class_level then
    local class_level = doc['CLASS & LEVEL']
    local class = class_level:match('%a+')
    local level = class_level:match('%d+%s*$')
    
    if not class then
      return false, "CLASS & LEVEL must contain a valid class name"
    end
    if not level then
      return false, "CLASS & LEVEL must end with a valid level number"
    end
    
    local level_num = tonumber(level)
    if not level_num or level_num < 1 or level_num > 20 then
      return false, string.format("level in CLASS & LEVEL must be 1-20, got %s", level)
    end
  end
  
  return true
end

local field_specs = {
  -- Each entry has: p (predicate), fs (field list), m (message), required (boolean)
  
  -- Required ability scores (1-20)
  { vd = inrange(1, 20),
    fs = {'STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA'} },
  
  -- Required basic character info
  { vd = optional(nonempty_string),
    fs = {'CHARACTER NAME', 'PLAYER NAME', 'RACE', 'BACKGROUND'} },
  
  -- Required numeric stats
  { vd = positive,
    fs = {'MAX HP', 'ARMOR CLASS', 'PASSIVE PERCEPTION'} },
  
  -- Required structured data
  { vd = optional(validate_equipment),
    fs = {'EQUIPMENT'} },
  { vd = optional(validate_attacks),
    fs = {'ATTACKS'} },
  { vd = optional(validate_features),  
    fs = {'FEATURES'} },
  { vd = optional(validate_magic),
    fs = {'MAGIC'} },
  { vd = optional(validate_proficiencies),
    fs = {'PROFICIENCIES', 'SECONDARY PROFICIENCIES'} },
    
  -- Optional fields that can be present
  { vd = optional(inrange(1, 20)),
    fs = {'LEVEL'} },
  { vd = optional(positive),  
    fs = {'SPELL DC', 'DOMAIN SPELLS', 'SPELLS KNOWN', 'SORCERY POINTS'} },
  { vd = optional(can_be('string', 'number')),
    fs = {'ALIGNMENT', 'HIT DICE', 'INITIATIVE', 'SPEED', 'EXPERIENCE POINTS',
          'CURRENT HIT POINTS', 'SENSES', 'PROFICIENCY BONUS', 'CP', 'SP', 'EP', 'GP', 'PP'} },
  { vd = optional(can_be 'string'),  
    fs = {'AGE', 'DESCRIPTION', 'MOTIVATION', 'SPECIALTY', 'CLASS', 'GM NOTES'} },
  { vd = optional(can_be 'boolean'),
    fs = {'PREGENERATED', 'MAGIC SEPARATE'} },
  { vd = optional(can_be 'table'),
    fs = {'DESCRIPTION & PERSONALITY'} },
}

local string_list_fields = {
  'EQUIPMENT', 'PROFICIENCIES', 'SECONDARY PROFICIENCIES',
  'AGE', 'DESCRIPTION', 'MOTIVATION', 'SPECIALTY', 'CLASS', 'GM NOTES',
}  


local validator = { }

do
  for _, spec in ipairs(field_specs) do
--require 'inspect'.show(spec)
    for _, field in ipairs(spec.fs) do
      assert(type(spec.vd) == 'function')
      validator[field] = spec.vd
    end
  end
end

-- Forward declaration
local value_string

local function table_string(t)
  -- Use Lua's unified syntax: show array elements first, then non-array keys
  local items = {}
  local max_n = table.maxn and table.maxn(t) or 0
  
  -- Add array elements 1, 2, 3, ..., max_n
  for i = 1, max_n do
    table.insert(items, value_string(t[i]))
  end
  
  -- Add non-array keys (keys that are not integers in range 1..max_n)
  local extra_items = {}
  for k, val in pairs(t) do
    if not (type(k) == 'number' and k >= 1 and k <= max_n and k == math.floor(k)) then
      local key_str
      if type(k) == 'string' and k:match('^[%a_][%w_]*$') then
        -- Valid identifier, no quotes needed
        key_str = k
      else
        -- Need to quote or bracket the key
        key_str = "[" .. value_string(k) .. "]"
      end
      table.insert(extra_items, key_str .. "=" .. value_string(val))
    end
  end
  table.sort(extra_items) -- Sort for consistent output
  
  -- Combine array and key-value elements
  for _, item in ipairs(extra_items) do
    table.insert(items, item)
  end
  
  return "{" .. table.concat(items, ", ") .. "}"
end

function value_string(v)
  if type(v) == 'string' then
    return stringf('%q', v)
  elseif type(v) == 'table' then
    -- Handle special cases
    if isnull(v) then
      return "null"
    end
    
    return table_string(v)
  else
    return tostring(v)
  end
end

local function validation_message(message, field, v)
  return message:format(stringf('%s [%s]', field, value_string(v)))
end

local function validate_font(s)
  if type(s) ~= 'string' or not s:find [[^\]] then
    verrorf('%s must be a LaTeX font command', image(s))
  end
end
    
    

-- Validation function  
local function validate_document(doc)
  -- Clear global validation errors from previous documents
  for field_name, value in pairs(doc) do
    -- Skip system-generated fields that shouldn't be validated  
    if not field_name:match(' SAVING$') then
      local thevalidator = validator[field_name]
      
      -- Handle font variants dynamically: if "X FONT" and X is valid, treat as optional LaTeX font command
      if not thevalidator and field_name:match(' FONT$') then
        local base_field = field_name:match('(.*) FONT$')
        if base_field and validator[base_field] then
          thevalidator = optional(validate_font)
        end
      end
      
      if thevalidator then
        -- Handle YAML null and nil as empty values
        local test_value = value
--        if value == nil or isnull(value) then
--          test_value = ""
--        end
        
        thevalidator(test_value)
      elseif fields.strict then
        -- In strict mode, unknown fields are errors
        verrorf("Unknown field: %s", field_name)
      elseif fields.verbose then
        -- In verbose mode, warn about unknown fields
        eprintf("Warning: Unknown field: %s\n", field_name)
      end
    end
  end
  
  if not empty(doc.WIS) and empty(doc['PASSIVE PERCEPTION']) then
    verrorf('WIS present but PASSIVE PERCEPTION missing')
  end

  -- Validate CLASS & LEVEL requirement
  local class_level_valid, class_level_msg = validate_class_level_requirement(doc)
  if not class_level_valid then
    -- Show relevant values for CLASS/LEVEL validation
    local relevant_values = {
      ["CLASS & LEVEL"] = doc["CLASS & LEVEL"],
      CLASS = doc.CLASS,
      LEVEL = doc.LEVEL
    }
    verrorf("CLASS/LEVEL [%s]: %s", value_string(relevant_values), class_level_msg)
  end
end




---------------------------------------------------------------------------
-- 1. TeX-escaping utility
---------------------------------------------------------------------------
local tex_escape_map = {
--  ["\\"] = [[\textbackslash{}]],
--  ["{"]  = [[\{]],
--  ["}"]  = [[\}]],
  [' '] = '~',
  ["&"]  = [[\&]],
  ["%"]  = [[\%]],
  ["$"]  = [[\$]],
  ["#"]  = [[\#]],
  ["_"]  = [[\_]],
  ["~"]  = [[\textasciitilde{}]],
  ["^"]  = [[\textasciicircum{}]],
}

local minustab = { ['-'] = [[\textminus]] }

local function escape (s)
  if isnull(s) then
    return ''
  else
    return (tostring(s):gsub("[\\&%%$#_{}~^]", tex_escape_map)
                       :gsub('([%s%d])%-(%d)', [[%1\textminus%2]])
                       :gsub("−", [[\textminus{}]]) 
    )
  end
end

local function do_not_escape(s) return tostring(s) end

local function keyformat(key)
  return (key:gsub('%&', '+'))
end


--- rendering
---
--- 

local render = { }
-- simple_kv (k, string): \setDND{k}{string} or \setDNDfont
-- item_list (vs): \item as_item(v1) ... \item as_item(vn)
-- as_item(v): \item scalar(v)
---------------------------------------------------------------------------
-- 3. Rendering helpers
---------------------------------------------------------------------------
local function is_empty_table(v)
  return type(v) == 'table' and next(v) == nil
end

local function is_list(v)
  return type(v) == 'table' and (v[1] or next(v) == nil)
end

local function is_named_list(entry) -- category: [a, b, c, ...]
  if type(entry) == 'table' then
    local k, v = next(entry)
    return type(k) == 'string' and is_list(v) and next(entry, k) == nil
  end
end

function render.simple_kv (key, val)
  local fontbase = key:match('(.*) FONT$')
  if fontbase then
    return ([[\setDNDfont{%s}{%s}]]):format(keyformat(fontbase), do_not_escape(val))
  else
    return ([[\setDND{%s}{%s}]]):format(keyformat(key), do_not_escape(val))
  end
end


function render.scalar(v)
  if type(v) == 'string' then
    return do_not_escape(v)
  elseif type(v) ~= 'table' then
    return tostring(v)
  else
    if isnull(v) or v.proficiencies_skip then
      return [[\profskip{}]]
    elseif is_named_list(v) then
      local name, elements = next(v)
      return stringf([[%s: \begin{innerlist}%s\end{innerlist}]], name, render.item_list(elements))
    elseif v.smallskip then
      return [[\smallskip{}]]
    elseif v.medskip then
      return [[\medskip{}]]
    else
      return 'whut?: ' .. (require 'inspect'.image(v))
    end
  end
end


function render.as_item(v)
  if is_empty_table(v) then -- blank list entry
    return [[\profskip{}]]
  else
    local s = render.scalar(v)
    if s:find [[\profskip]] or s:find [[\medskip]] or s:find [[\smallskip]]
    or s:find [[\bigskip]]
    then
      return s
    else
--if s:find '_' then require 'inspect'.show { evil_string = s } end
      return ([[\item %s]]):format(do_not_escape(s))
    end
  end
end

function render.item_list (list)
  local items = {}
  for _,v in ipairs(list) do
    table.insert(items, render.as_item(v))
  end
  return table.concat(items, "\n")
end

function render.attack_record (rec)
  local parts = {}
  if type(rec.ATTACK) == 'number' then
    rec.ATTACK = stringf('%+d', rec.ATTACK)
  end
--  for _, k in ipairs { "NAME", "ATTACK", "DAMAGE", "TYPE", "RANGE", "AMMO TYPE", "AMMO COUNT", 'NOTES' }
--  do
--    outf(parts, "%s={%s}", do_not_escape(k), do_not_escape(rec[k] or ""))
--  end
  for k, v in pairs(rec) do
    outf(parts, "%s={%s}", do_not_escape(k), do_not_escape(v))
  end
  return ([[\dndkeys{%s}]]):format(table.concat(parts, ","))
end

function render.generic_record (rec)
  local parts = {}
  for k,v in pairs(rec) do
    outf(parts, "%s={%s}", do_not_escape(k), do_not_escape(v))
  end
  table.sort(parts)
  return ([[\dndkeys{%s}]]):format(table.concat(parts, ","))
end

local function note(elem)
  return elem.NOTE  and not isnull(elem.NOTE)  and elem.NOTE :find '%S' and elem.NOTE or
         elem.NOTES and not isnull(elem.NOTES) and elem.NOTES:find '%S' and elem.NOTES
end



function render.struct_list (key, list)
  vprintf('rendering struct for %s\n', key)
  local out = {}
  local notes_header_out = false
  for _,elem in ipairs(list) do
    if type(elem) ~= "table" then
      outf(out, [[\item %s]], do_not_escape(tostring(elem)))
    elseif elem.level and (elem.slots or not next(elem, 'level')) then
      if type(elem.level) == 'table' then
        verrorf('Spell-level table uses old format; switch to { level: N, slots: M }')
        elem.level = 99
      end
      if elem.slots then
        outf(out, [[\spellslevellabel{%s}{%s}]], elem.level, elem.slots)
      else
        outf(out, [[\spellslevellabel{%s}{%s}]], do_not_escape(elem.level), 0)
      end
    elseif elem.name and elem.description and not elem.ATTACK
        or key == 'MAGIC'
    then
      local suffix =
        (elem.attack or elem.offense or elem.offensive or elem.save or elem.enemy)
        and 'Colored{attacks}' or ''
      outf(out, [[\described%s{%s}{%s}]], suffix,
           do_not_escape(elem.name or ''), do_not_escape(elem.description or ''))
    elseif false and elem.ATTACK then
      vprintf('rendering an attack\n')
      table.insert(out, render.attack_record(elem))
    else
      table.insert(out, render.generic_record(elem))
    end
  end

  return ([[\setDND{%s}{%s}]]):format(keyformat(key), table.concat(out, "\n"))
end

---------------------------------------------------------------------------
-- 3.5. Equipment string list parsing
---------------------------------------------------------------------------

local category_map = {
  ["heavy weapon"] = "HEAVY WEAPONS",
  ["normal weapon"] = "NORMAL WEAPONS",
  ["light weapon"] = "LIGHT WEAPONS",
  ["shield"] = "SHIELDS",
  ["heavy armor"] = "HEAVY ARMOR",
  ["heavy armour"] = "HEAVY ARMOR",
  ["normal armor"] = "MEDIUM ARMOR",
  ["normal armour"] = "MEDIUM ARMOR", 
  ["medium armor"] = "MEDIUM ARMOR",
  ["medium armour"] = "MEDIUM ARMOR",
  ["light armor"] = "LIGHT ARMOR",
  ["light armour"] = "LIGHT ARMOR",
  ["heavy item"] = "HEAVY ITEMS",
  ["slotted item"] = "SLOTTED ITEMS",
  ["free item"] = "SMALL ITEMS",
  ["small item"] = "SMALL ITEMS",
  ["stored item"] = "STORED ITEMS",
  ["stored"] = "STORED ITEMS",
}

-- Extract valid equipment categories from category_map (single point of truth)
valid_equipment_categories = {}
for _, category in pairs(category_map) do
  valid_equipment_categories[category] = true
end

local function strip_s(s)
  if s:sub(-1) == 's' then
    return s:sub(1, -2)
  else
    return s
  end
end

local function category(s)
  return category_map[strip_s(s:lower())]
end

local function heuristic_category(s)
  return 'SLOTTED ITEMS'
end

---------------------------------------------------------------------------
-- 3.6. Equipment format detection and processing
---------------------------------------------------------------------------

local function is_string_list_with_categories(equipment_data)
  if type(equipment_data) ~= "table" or #equipment_data == 0 then
    return false
  end
  if type(equipment_data[1]) ~= "string" and type(equipment_data[1]) ~= "number" then
    return false
  end
  -- Check if any item has category syntax
  local has_category_syntax = function(item)
    return type(item) == "string" and (item:find(":%s*$") or item:find("^-"))
  end
  return any(has_category_syntax, equipment_data)
end

local function is_structured_object(equipment_data)
  if type(equipment_data) ~= "table" or #equipment_data > 0 then
    return false
  end
  -- Has string keys (categories) rather than numeric indices
  return next(equipment_data) ~= nil
end


-- Helper functions for equipment processing
local function extract_weight_arg(category, equipment_item)
  if category == "HEAVY ITEMS" then
    local stones = equipment_item:match("%((%d+) stones?%)")
    if stones then
      return string.format("[%d]", tonumber(stones) * 10)
    end
  end
  return ""
end

local function add_equipment_item(category, equipment_item, lines, flattened_equipment)
  local weight_arg = extract_weight_arg(category, equipment_item)
  table.insert(lines, string.format("\\addDNDitem%s{%s}{%s}", 
    weight_arg, category:gsub('&', '+'), do_not_escape(equipment_item)))
  table.insert(flattened_equipment, render.as_item(equipment_item))
end

-- Process structured equipment and generate LaTeX output
local function emit_structured_equipment(structured_equipment, lines)
  local flattened_equipment = {}
  
  -- Process all categories
  for category, items in pairs(structured_equipment) do
    if type(items) == "table" and #items > 0 then
      if category ~= "UNCATEGORIZED" then
        -- Categorized items get \addDNDitem commands
        for _, equipment_item in ipairs(items) do
          add_equipment_item(category, equipment_item, lines, flattened_equipment)
        end
      else
        -- Uncategorized items only go to flattened list
        for _, equipment_item in ipairs(items) do
          table.insert(flattened_equipment, render.as_item(equipment_item))
        end
      end
    end
  end
  
  -- Emit flattened equipment list
  if #flattened_equipment > 0 then
    table.insert(lines, string.format("\\setDND{EQUIPMENT}{%s}", 
      table.concat(flattened_equipment, "\n")))
  else
    table.insert(lines, "\\setDND{EQUIPMENT}{}")
  end
end

-- Parse equipment from a list of strings into structured format
-- Supports both inline format ("NORMAL WEAPONS: Longsword") and
-- block format ("NORMAL WEAPONS:", "- Longsword", "- Shortbow")
local function parse_equipment_strings(lines)
  local equipment = {}
  local i = 1

  local function add(category, item)
    equipment[category] = equipment[category] or {}
    table.insert(equipment[category], item)
  end
  
  while i <= #lines do
    -- see grammar for EQUIPMENT in YAML.md
    local line = lines[i]:gsub("^%s+", ""):gsub("%s+$", "") -- trim whitespace
    local block_header = line:match("^(.+):$")
    
    if line == "" then
      -- Skip empty lines
      i = i + 1
    elseif block_header and category(block_header) then
      -- Block format category header: "CATEGORY:"
      local cat = category(block_header)
      equipment[cat] = equipment[cat] or {} -- populate even if no items follow
      i = i + 1
      while i <= #lines and lines[i]:find '^%s*%-%s' do
        local item = lines[i]:gsub("^%s*%-%s+", ""):gsub("%s+$", "")
        add(cat, item)
        i = i + 1
      end
    elseif block_header then
      eprintf("Warning: Unknown equipment category %q\n", block_header)
      i = i + 1
    elseif line:match("^%S.*:") then
      -- Inline format: "CATEGORY: Item Name"
      local cat, item = assert(line:match("^([^:]-)%s*:%s*(.*)$"))
      if category(cat) then
        add(category(cat), item)
      else
        eprintf("Warning: Unknown equipment category %q in line %q\n", cat, line)
      end
      i = i + 1
    else
      add(heuristic_category(line), line)
      i = i + 1
    end
  end
  return equipment
end

-- Convert any equipment format to unified structured format
local function equipment(equipment_data)
  if is_string_list_with_categories(equipment_data) then
    return parse_equipment_strings(equipment_data)
  elseif is_structured_object(equipment_data) then
    return equipment_data -- already in structured format
  elseif type(equipment_data) == "table" and #equipment_data > 0 then
    -- Traditional string list - put everything in heuristic category
    local result = {}
    result[heuristic_category()] = equipment_data
    return result
  else
    return {} -- empty equipment
  end
end

-- Helper function to visualize table structure for debugging
local function visualize_table(t, indent)
  indent = indent or 0
  local spaces = string.rep("  ", indent)
  local result = {}
  for k, v in pairs(t) do
    if type(v) == "table" then
      table.insert(result, spaces .. tostring(k) .. " = {")
      table.insert(result, visualize_table(v, indent + 1))
      table.insert(result, spaces .. "}")
    else
      table.insert(result, spaces .. tostring(k) .. " = " .. tostring(v))
    end
  end
  return table.concat(result, "\n")
end

-- Local recursive table equality comparison
local function table_eq(t1, t2)
  if t1 == t2 then
    return true
  elseif type(t1) ~= 'table' or type(t2) ~= 'table' then
    return false
  else
    for k, v in pairs(t1) do
      if not table_eq(v, t2[k]) then
        return false
      end
    end
    for k, v in pairs(t2) do
      if t1[k] == nil then
        return false
      end
    end
    return true
  end
end

-- Convert structured equipment back to string list format
local function unparse_equipment_structure(structured_equipment)
  local lines = {}
  
  -- Helper to capitalize first letter of each word
  local function capitalize(s)
    return s:gsub("(%a)([%w_']*)", function(first, rest)
      return first:upper() .. rest:lower()
    end)
  end
  
  -- Helper to get singular form and proper capitalization
  local function format_category_name(category)
    return capitalize(category:lower():gsub("s$", ""))
  end
  
  for category, items in pairs(structured_equipment) do
    if type(items) == "table" then
      if #items == 1 then
        -- Single item: use inline format
        local formatted_category = format_category_name(category)
        table.insert(lines, formatted_category .. ": " .. items[1])
      else
        -- Multiple items or empty: use block format
        local formatted_category = format_category_name(category)
        table.insert(lines, formatted_category .. "s:")
        for _, item in ipairs(items) do
          table.insert(lines, "- " .. item)
        end
      end
    end
  end
  
  return lines
end

-- Round-trip validation function
local function validate_equipment_parsing(structured_equipment)
  -- Skip validation for empty structures
  if not structured_equipment or (type(structured_equipment) == "table" and next(structured_equipment) == nil) then
    return structured_equipment
  end
  
  -- Skip round-trip validation if equipment structure is invalid
  local valid, _ = validate_equipment(structured_equipment)
  if not valid then
    return structured_equipment  -- Return invalid structure as-is, validation errors already reported
  end
  
  -- Unparse to string list format
  local unparsed_lines = unparse_equipment_structure(structured_equipment)
  
  -- Parse it back
  local reparsed_structure = parse_equipment_strings(unparsed_lines)
  
  -- Compare with original
  if not table_eq(structured_equipment, reparsed_structure) then
    error(string.format("Equipment round-trip validation failed!\nOriginal:\n%s\n\nUnparsed lines:\n%s\n\nReparsed:\n%s", 
      visualize_table(structured_equipment),
      table.concat(unparsed_lines, "\n"),
      visualize_table(reparsed_structure)))
  end
  
  return structured_equipment
end

---------------------------------------------------------------------------
-- 4. Convert a single YAML mapping to LaTeX lines
---------------------------------------------------------------------------
local function convert_mapping (map)
  local lines = {}

  do -- set proficiency bonus first
    local level = tonumber(map.LEVEL)
    local prof = level and (2 + math.floor((level - 1) / 4)) or 2
    outf(lines, [[\setcounter{proficiency bonus}{%d}]], prof)
  end

  -- emit keys in predictable order
  local keys = {}
  for k in pairs(map) do table.insert(keys, k) end
  table.sort(keys)

  local use_items = { PROFICIENCIES = true,
                      ['SECONDARY PROFICIENCIES'] = true,
  }

  for _, k in ipairs(keys) do
    local v = map[k]
    local t = type(v)
    if k == "EQUIPMENT" and t == "table" then
      emit_structured_equipment(validate_equipment_parsing(equipment(v)), lines)
    elseif t=="string" or t=="number" or t=="boolean" then
      table.insert(lines, render.simple_kv(k, tostring(v)))
    elseif t=="table" then
      if use_items[k]
      or (#v > 0 and (type(v[1])=="string" or type(v[1])=="number"))
      then
        table.insert(lines, render.simple_kv(k, render.item_list(v)))
      else
        table.insert(lines, render.struct_list(k, v))
      end
    end
  end
  return table.concat(lines, "\n")
end

---------------------------------------------------------------------------
-- 5. Entry point
---------------------------------------------------------------------------
local function slurp(filename)
  if filename == '-' or filename == '.' or not filename then
    return io.stdin:read("*a")
  else
    local f = assert(io.open(filename, "r"))
    local txt = f:read("*a"); f:close(); return txt
  end
end

local saving_throw_proficiencies = {
  Barbarian = { "Strength", "Constitution" },
  Bard      = { "Dexterity", "Charisma" },
  Cleric    = { "Wisdom", "Charisma" },
  Druid     = { "Intelligence", "Wisdom" },
  Fighter   = { "Strength", "Constitution" },
  Monk      = { "Strength", "Dexterity" },
  Paladin   = { "Wisdom", "Charisma" },
  Ranger    = { "Strength", "Dexterity" },
  Rogue     = { "Dexterity", "Intelligence" },
  Sorcerer  = { "Constitution", "Charisma" },
  Warlock   = { "Wisdom", "Charisma" },
  Wizard    = { "Intelligence", "Wisdom" }
}


local function same_values(v1, v2)
  local s1, s2 = tostring(s1), tostring(s2)
  return v1 == v2 or
         s1:find '^%d+$' and s2 == '+' .. s1 or
         s2:find '^%d+$' and s1 == '+' .. s2
end

local function has_perception(t)
  if type(t) == 'table' then
    for p in scalarvalues(t) do
      if type(p) == 'string' and p:lower():find 'perception' then
        return true
      end
    end
  end
end



local function preprocess(doc)
  for _, f in ipairs(string_list_fields) do
    doc[f] = convert_colon_tables(doc[f])
  end

  -- work around parsing in javascript 
  for _, f in ipairs {'PROFICIENCIES', 'SECONDARY PROFICIENCIES'}
  do
    local t = doc[f]
    if islist(t) then
      for i, l in ipairs (t) do
        if l == '' then
          t[i] = lyaml.null
        end
      end
    end
  end

  return doc
end

local function extend(doc)

  if fields.nocolor then
    doc.COLOR = false
  end

  local function update(field, value) -- checks for consistency
    local v = doc[field]
    if v and tostring(v):find '%S' and not same_values(v, value) then
      verrorf('Value %s computed as %s, but input says %s\n',
              field, tostring(value), tostring(v))
    elseif not tostring(v):find '^%+' then
      doc[field] = value
    end
  end
    
      

  local class = doc.CLASS or (doc['CLASS & LEVEL'] or ''):match '%a+' or ''
  doc.CLASS = class
  
  -- Extract SPECIALTY from "CLASS & LEVEL" if SPECIALTY is absent
  if not doc.SPECIALTY and doc['CLASS & LEVEL'] then
    doc.SPECIALTY = doc['CLASS & LEVEL']:match '%a+%s*%(([^)]+)%)'
  end
  
  -- Extract LEVEL from "CLASS & LEVEL" if LEVEL is absent
  doc.LEVEL = doc.LEVEL or
              doc['CLASS & LEVEL'] and doc['CLASS & LEVEL']:match '%d+%s*$' or
              nil
  
  -- Only build "CLASS & LEVEL" if we have separate CLASS/LEVEL/SPECIALTY fields
  if doc.CLASS and doc.LEVEL and not doc['CLASS & LEVEL'] then
    if doc.SPECIALTY and doc.SPECIALTY:find '%S' then
      doc['CLASS & LEVEL'] = stringf('%s (%s) %s', class, doc.SPECIALTY, doc.LEVEL)
    else
      doc['CLASS & LEVEL'] = stringf('%s %s', class, doc.LEVEL)
    end
  end
  
  local p = saving_throw_proficiencies[class]
  if p then
    for _, prof in ipairs(p) do
      doc[stringf('%s SAVING', prof:sub(1,3):upper())] = true
    end
  end

  local level = tonumber(doc.LEVEL) or 1
  local prof_bonus = 2 + math.floor((level - 1) / 4)


  -- Handle SPELL DC calculation and validation
  if not empty(doc.MAGIC) then
    local cm = casting_modifier[class]
    if not empty(cm) and not empty(doc[cm]) then
      -- Calculate spell DC: 8 + proficiency bonus + ability modifier
      local ability_score = tonumber(doc[cm])
      local ability_modifier = math.floor((ability_score - 10) / 2)
      
      update('SPELL DC', 8 + prof_bonus + ability_modifier)
      update('SPELL ATTACK MODIFIER', stringf('+%d', prof_bonus + ability_modifier))
      update('SPELLCASTING ABILITY MODIFIER', ability_modifier)
    end
  end

  -- Handle PASSIVE PERCEPTION calculation and validation
  if not empty(doc.WIS) then
    -- Check if character has Expertise feature (case-insensitive)
    local has_expertise = false
    if doc.FEATURES and type(doc.FEATURES) == "table" then
      for _, feature in ipairs(doc.FEATURES) do
        if type(feature) == "table" and feature.name and 
           type(feature.name) == "string" and feature.name:lower():find('expertise') then
          has_expertise = true
          break
        end
      end
    end
    
    local proficient_perceiver =
      has_perception(doc.PROFICIENCIES or doc['SECONDARY PROFICIENCIES'])

    if not has_expertise then
      -- Calculate passive perception: 10 + WIS modifier + proficiency bonus
      local wis_score = tonumber(doc.WIS)
      local wis_modifier = math.floor((wis_score - 10) / 2)
      local calculated_pp =
        10 + wis_modifier + (proficient_perceiver and prof_bonus or 0)
      
      if not empty(doc['PASSIVE PERCEPTION']) then
        -- Validate existing PASSIVE PERCEPTION
        local existing_pp = tonumber(doc['PASSIVE PERCEPTION'])
        if existing_pp and existing_pp ~= calculated_pp then
          verrorf('PASSIVE PERCEPTION mismatch: got %d, expected %d (10 + WIS mod %+d + prof %d)', 
                  existing_pp, calculated_pp, wis_modifier, prof_bonus)
        end
      else
        -- Set calculated PASSIVE PERCEPTION
        doc['PASSIVE PERCEPTION'] = calculated_pp
      end
    end
  end

  --- GM things.  Not clear to me this should be done with variables


  if not doc['BONUS ACTIONS'] then
    local function stripname(s)
      return s:gsub([[\rlap%b{}]], function(t) return t:sub(7,-2) end)
              :gsub([[\footnotesize%s*]], '')
              :gsub('%s*%b[]', '')
              :gsub('%s+$', '')
    end
    local bonuses = { }
    for _, section in ipairs {'MAGIC', 'FEATURES'} do
      local things = doc[section] or nothing
      for _, thing in ipairs(things) do
        if thing.name and thing.bonus then
          local name = stripname(thing.name)
          local description =
            thing['GM note'] and stringf('%s [%s]', name, thing['GM note']) or name
          table.insert(bonuses, stringf([[\bonus{%s}]], description))
        end
      end
    end
    doc['BONUS ACTIONS'] = table.concat(bonuses, '\\relax\n')
  end


  return doc
end

local function contents(filename)
  local f, msg = io.open(filename, 'r')
  if not f then return f, msg end
  local s, msg = f:read '*a'
  if not s then return s, string.format('%s: %s', filename, msg) end
  f:close()
  return s
end

local function set_contents(filename, s)
  local f, msg = io.open(filename, 'w')
  if not f then return f, msg end
  local s = assert(f:write(s))
  f:close()
  return s or true
end

local quote_me = '[^%w%+%-%=%@%_%/%.%:]' -- easier to complement what doesn't need quotes
local strfind = string.find

local function dirname(s) -- also returns basename as second result
  s = s:gsub('/$', '')
  local dir, base = s:match '^(.*)/([^/]*)$'
  if not dir then
    return '.', s
  elseif dir == '' then
    return '/', base
  else
    return dir, base
  end
end


function osquote(s)
  -- Returns string s with whatever markup is needed to quote it 
  -- to the POSIX shell.

  if strfind(s, quote_me) or s == '' then
    return "'" .. string.gsub(s, "'", [['"'"']]) .. "'"
  else
    return s
  end
end

local function fill_template(assignments, layout)
  local pathname = stringf('%s/%s.tex', fields.templates, layout)
  local template, msg = contents(pathname)
  if not template then
    eprintf('%s\n', msg)
    os.exit(1)
  else
    local bracketed_splash = stringf('{%s/splash.png}', fields.templates)
    return (template:gsub('\n[ \t]*\\input%b{}', '\n' .. assignments)
                    :gsub('%{splash.png%}', bracketed_splash)
           )
  end
end

local quote_me = '[^%w%+%-%=%@%_%/%.%:]' -- easier to complement what doesn't need quotes
local function shell_quote(s)
  if s:find(quote_me) or s == '' then
    return "'" .. string.gsub(s, "'", [['"'"']]) .. "'"
  else
    return s
  end
end


local runlatex = [=[
pdflatex=$PDFLATEX
output="$OUTPUT"

dir="$(mktemp -d)"
trap "rm -rf $dir" 0
tee /tmp/debug > "$dir/sheet.tex"
$pdflatex -output-directory "$dir" "$dir/sheet.tex"
rc=$?

if [[ $rc != 0 ]]; then
  exit $rc
fi

if [[ -r "$dir/sheet.pdf" ]]; then
  cp "$dir/sheet.pdf" "$output"
else
  rm -f "$output"
fi
]=]

local function wrap_latex(latex, layout, font)
  local output = fields.standalone and latex or fill_template(latex, layout)
  if font then
    output = output:gsub([[\documentclass.-%d+pt.-article]],
      function(line1)
        return (line1:gsub('%d+pt', font))
      end)
  end
  return output
end

local function process(output)
  if not fields.output then
    io.stdout:write(output, '\n')
  elseif fields.output:find '%.tex$' then
    set_contents(fields.output, output)
  elseif fields.output:find '%.pdf$' then
    local command = runlatex:gsub('%$PDFLATEX', shell_quote(pdflatex))
                            :gsub('%$OUTPUT', shell_quote(fields.output))
    local fd = assert(io.popen(stringf('bash -c %s', shell_quote(command)), 'w'))
    fd:write(output)
    fd:close()
    do -- check success
      local fd = io.open(fields.output)
      if fd then
        fd:close()
      else
        os.exit(1)
      end
    end
--
--    local tex = fields.output:gsub('%.pdf$', '.tex')
--    set_contents(tex, output)
--    local rc = runf('%s -output-directory %s %s',
--                    pdflatex, osquote(dirname(fields.output)), osquote(tex))
--    if rc ~= 0 then
--      os.exit(rc)
--    end
  end
end

local function sheet_of_file(pathname)
  curfile = pathname
  local yaml_text = slurp(pathname)
  local ok, doc, msg = pcall(lyaml.load, yaml_text)
  if not ok or type(doc) ~= 'table' then
    eprintf('charsheet load failed %s\n', (not ok and doc) or msg or 'YAML loaded as string')
    os.exit(1)
  end
  assert(type(doc) == 'table')

  do -- look for unbalanced braces (security risk)
    local bad = unbalanced_yaml_string(doc)
    if bad then
      local replace =
        { ['{'] = [[\lbrace{}]], ['}'] = [[\rbrace{}]], ['\\'] = [[\textbackslash{}]] }
      local display = bad:gsub([=[[{}\]]=], replace)
      process(bad_input_tex:gsub("%$BAD", display))
      return
    end
  end
    
  local font = doc['DOCUMENT FONT']
  doc['DOCUMENT FONT'] = nil

  -- Validate document before processing
  preprocess(doc)
  validate_document(doc)
  extend(doc)
  if #global_validation_errors > 0 then
    if fields.strict then
      eprintf("Validation failed in strict mode. Exiting.\n")
      os.exit(1)
    else
      eprintf("Validation warnings encountered. Continuing...\n")
      -- In non-strict mode, accumulate validation errors in the document
      doc['VALIDATION ERRORS'] = global_validation_errors
    end
  end
  return doc
end

local scripts = { }
function scripts.charsheet(arg)
  local doc = sheet_of_file(arg[1])
  local layout = fields.layout or doc.LAYOUT or default_layout
  local latex = sanitize_control_sequences(escape(convert_mapping(doc)))
  process(wrap_latex(latex, layout, font))
end

local function plus_newline(s)
  return s .. '\n'
end

local function namelt (t1, t2) return t1.name < t2.name end

function scripts.gmsheet(arg)
  local latexes = { }
  local docs = { }
  for i, playerfile in ipairs(arg) do
    local doc = sheet_of_file(playerfile)
    table.insert(docs, doc)
    local defs = sanitize_control_sequences(escape(convert_mapping(doc)))
    table.insert(latexes, stringf(plus_newline [[\setDNDplayer{%d}{%s}]], i, defs))
  end

  do -- durable effects
    local function dname(thing)
      local s = thing.name
      local concentration = ''
      if thing.concentration or s:find('%b[]') and s:find('%AC%A') then
        concentration = [[ \C]]
      end
      return s:gsub('%s+%b[]', ''):gsub([[\rlap%s*%b{}]], ''):gsub(',%s*$', '') ..
             concentration
    end

    local durables = { }
    for _, doc in ipairs(docs) do
      for thing in named_things(doc) do
        if thing.duration then
          table.insert(durables, thing)
        end
      end
    end
    table.sort(durables, namelt)
    local code = {}
    local function outdurable(thing)
      local duration = stringf([[\?%s]], thing.duration):gsub([[%\%?(%d%d)]], '%1')
      outf(code, plus_newline [[  \durable{%s}{%s}%%]], dname(thing), duration)
    end
    local function outdurables(lo, hi)
      outf(code, '%%\n {%%\n')
      for i = lo, hi do
        outdurable(durables[i])
      end
      outf(code, ' }')
    end
    outf(code, [[\def\durables{]])
    local mid = math.ceil(#durables/2.0)
    outdurables(1, mid)
    outdurables(mid+1, #durables)
    outf(code, '}')

    table.insert(latexes, table.concat(code, ''))
  end
 
  do -- attack spells
    local attacks = { }
    for _, doc in ipairs(docs) do
      for spell in named_things(doc) do
        if spell.attack then
          table.insert(attacks, spell)
        end
      end
    end
    table.sort(attacks, namelt)
    for i, attack in ipairs(attacks) do
      attacks[i] = stringf([[\attack{%s}]], attack.name)
    end
    table.insert(latexes,
                 stringf([[\def\spellattacks]] .. '{%%\n  %s%%\n}%%\n',
                         table.concat(attacks, '%\n  ')))
  end

  local function first_initial(doc)
    local first = (doc['CHARACTER NAME'] or 'Nobody'):match '%u'
    return first
  end

  do -- saving-throw spells
    local savedocs = { } -- map spell name to list of docs
    local savestats = { } -- and to stat
    for _, doc in ipairs(docs) do
      for spell in named_things(doc) do
        if spell.save then
          local name = spell.name:gsub('%s*%b[]', '')
          savestats[name] = spell.save
          savedocs[name] = savedocs[name] or {}
          table.insert(savedocs[name], doc)
        end
      end
    end
    local savekeys = { }
    for spell in pairs(savedocs) do
      table.insert(savekeys, spell)
    end
    require 'inspect'.show { savekeys = savekeys }
    table.sort(savekeys)
    for i, spellname in ipairs(savekeys) do
      local dcs = { }
      for _, doc in ipairs(savedocs[spellname]) do
        local dc = tonumber(doc['SPELL DC'])
        dcs[dc] = dcs[dc] or { }
        table.insert(dcs[dc], doc)
      end
      local suffix
      if is_singleton_table(dcs) then
        require 'inspect'.show(dcs)
        suffix = stringf([[\textsc{%s}~%d]], savestats[spellname], (next(dcs)))
      else
        local dclist = { }
        for _, doc in ipairs(savedocs[spellname]) do
          local s = stringf('%s,~%d', first_initial(doc), tonumber(doc['SPELL DC']))
          table.insert(dclist, s)
        end
        suffix =
          stringf([[\textsc{%s}: %s]], savestats[spellname], table.concat(dclist, '; '))
      end
      savedocs[i] = stringf([[\savespell{%s}{%s}]], spellname, suffix)
    end
    table.insert(latexes,
                 stringf([[\def\spellsaves]] .. '{%%\n  %s%%\n}%%\n',
                         table.concat(savedocs, '%\n  ')))
  end

    
    

  local layout = fields.layout or default_layout
  process(wrap_latex(table.concat(latexes, '\n'), layout, font))
end

if scripts[basename] then
  scripts[basename](arg)
else
  dief('%s: I expected to be called as `charsheet` or `gmsheet`.\n')
end

